#version 460 core

const int edgeVertexIndices[24] = {
    0, 1, 1, 3, 3, 2, 2, 0, 4, 5, 5, 7,
    7, 6, 6, 4, 0, 4, 1, 5, 3, 7, 2, 6
};

const int edgeTable[256] = {
	0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f, 0xb06, 
	0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00, 
	0x190, 0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96, 
	0x596, 0x49f, 0x795, 0x69c, 0xd9a, 0xc93, 0xf99, 0xe90, 
	0x230, 0x339, 0x33, 0x13a, 0xa3c, 0xb35, 0x83f, 0x936, 
	0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39, 0xd30, 
	0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6, 
	0x7a6, 0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0, 
	0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6, 
	0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 
	0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f, 0x256, 
	0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650, 
	0xaf0, 0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6, 
	0xef6, 0xfff, 0xcf5, 0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 
	0xb60, 0xa69, 0x963, 0x86a, 0x36c, 0x265, 0x16f, 0x66, 
	0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569, 0x460, 
	0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66, 
	0x66, 0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60, 
	0x5f0, 0x4f9, 0x7f3, 0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6, 
	0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 
	0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f, 0xd56, 
	0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950, 
	0x7c0, 0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6, 
	0x3c6, 0x2cf, 0x1c5, 0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0, 
	0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac, 0x5a5, 0x6af, 0x7a6, 
	0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9, 0x3a0, 
	0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636, 
	0x936, 0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230, 
	0xe90, 0xf99, 0xc93, 0xd9a, 0x69c, 0x795, 0x49f, 0x596, 
	0xa96, 0xb9f, 0x895, 0x99c, 0x29a, 0x393, 0x99, 0x190, 
	0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f, 0x406, 
	0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0, 
};

layout(std430, binding = 0) buffer TriTable {
    int triTable[];
};

layout (points) in;
layout (triangle_strip, max_vertices = 12) out;

uniform mat4 uMVP;
uniform mat4 uM;
uniform float uZoom;
uniform float uIsoValue;
uniform bool uDrawBox;
uniform bool uCPU;
uniform vec3 uOrigin;
uniform vec3 uLimits;
uniform vec3 uSpacing;
uniform vec3 uSteps;
uniform sampler3D volumeTex;

layout (location = 0) in vec3 aVoxelPos[];

layout (location = 0) out vec3 aTexCoord;
layout (location = 1) out vec3 aNormal;
layout (location = 2) out vec3 aFragPos;
layout (location = 3) out vec3 aColor;

void main()
{
    vec3 position = aVoxelPos[0];
    vec3 neighbours[8] = {
        position, vec3(position.x + uSteps.x, position.y, position.z),
        vec3(position.x, position.y + uSteps.y, position.z), vec3(position.x + uSteps.x, position.y + uSteps.y, position.z),
        vec3(position.x, position.y, position.z + uSteps.z), vec3(position.x + uSteps.x, position.y, position.z + uSteps.z),
        vec3(position.x, position.y + uSteps.y, position.z + uSteps.z), vec3(position.x + uSteps.x, position.y + uSteps.y, position.z + uSteps.z)
    };
    
    float scalars[8];
    int bitmask = 0;
    for (int idx = 0; idx < 8; idx++) {
        float val = texture(volumeTex, neighbours[idx]).r;
        bitmask |= (((val <= uIsoValue) ? 1 : 0) << idx);
        scalars[idx] = val;
    }

    vec3 isoPoints[12];
    for (int edge = 0; edge < 12; edge++) {
        // We need to find isopoint for this edge
        if ((edgeTable[bitmask] & (1 << edge)) != 0) {
            int v0Idx = edgeVertexIndices[edge * 2];
            int v1Idx = edgeVertexIndices[edge * 2 + 1];
            
            float denom = scalars[v1Idx] - scalars[v0Idx];
            float t = (abs(denom) < 1e-6) ? 0.5 : (uIsoValue - scalars[v0Idx]) / denom;
            vec3 isoPoint = neighbours[v0Idx] + (neighbours[v1Idx] - neighbours[v0Idx]) * t;
            
            // Now we compute the point in object space
            isoPoint = uOrigin + isoPoint * uSpacing * uLimits; 
            isoPoints[edge] = isoPoint;
        }
    }
    
    int curIdx = 0;
    int base = bitmask * 16;
    while (curIdx <= 13 && triTable[base + curIdx] != -1) {
        vec3 v[3];
        for (int j = 0; j < 3; j++) {
            v[j] = isoPoints[triTable[base + curIdx + j]];    
        }
        
        vec3 d1 = v[1] - v[0];
        vec3 d2 = v[2] - v[0];
        vec3 nvec = cross(d2, d1);
        float nlen = length(nvec);
        
        // Skip degenerate triangle
        if (nlen < 1e-6) {
            curIdx += 3;
            continue;
        }
        
        vec3 normal = normalize(mat3(uM) * nvec);
        for (int j = 0; j < 3; j++) {
            vec4 pos = uMVP * vec4(v[j], 1.0);
            pos.xyz = pos.xyz * uZoom;
            gl_Position = pos;
            aTexCoord = vec3(0);
            aNormal = normal;
            aFragPos = (uM * vec4(v[j], 1.0)).xyz;
            aColor = position + uSteps;
            EmitVertex();
        }

        EndPrimitive(); 
        curIdx += 3;
    }
}

